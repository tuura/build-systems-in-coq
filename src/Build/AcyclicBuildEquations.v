Require Import Data.Maybe.
Require Import Data.Functor.
Require Import Data.Functor.Identity.
Require Import Control.Applicative.
Require Import Control.Monad.
Require Import Control.Monad.StateInductive.
Require Import Build.
Require Import Build.Task.Monad.
Require Import Build.AcyclicTask.
Require Import Build.Store.

Require Import Coq.Program.Wf.

From Equations Require Import Equations.
Require Import Equations.Subterm.

Open Scope monad_scope.

Definition undefined {a : Type} : a. Admitted.

Equations busyFetch {V : Type} (k:nat) (tasks :  AcyclicTasks Monad V)
  : State (Store unit nat V) V :=
busyFetch k tasks by rec k lt :=
busyFetch k tasks :=
  match tasks k with
  | Nothing   => gets (getValue k)
  | Just task =>
    (run task)
    (fun n => busyFetch (proj1_sig n) tasks)
    >>=
    (fun v => modify (putValue k v) >> pure v)
  end.
Next Obligation.
Defined.
Print All.

Transparent busyFetch_unfold.

Definition busy {V : Type}
  (tasks : AcyclicTasks Monad V)
  (key : nat)
  (store : Store unit nat V) : Store unit nat V :=
  snd (runState (busyFetch key tasks) store).

(* Fibonacci *)
Definition store_fibo (zero : nat) (one : nat) :=
  mkStore unit nat nat tt
          (fun k => match k with
                    | 0 => zero
                    | 1 => one
                    | _ => undefined
                    end).

Definition fibo_generalized (zero : nat) (one : nat) (rank : nat) :=
  getValue rank (busy fibonacci rank (store_fibo zero one)).

(* 'Eval compute' gives a huge term here, thus we use 'Compute'.  *)
(* See http://gallium.inria.fr/blog/coq-eval/ on Coq's mechanisms *)
Compute fibo_generalized 1 1 5.

(* result and store agree on inputs, that is, for all input keys k ∈ I : *)
(* getValue k result == getValue k store. *)
(* In other words, no inputs were corrupted during the build. *)
Lemma busy_does_not_corrupt_inputs
  {V : Type}
  (tasks : AcyclicTasks Monad V)
  (key : nat)
  (store : Store unit nat V) :
  tasks key = Nothing -> getValue key (busy tasks key store) = getValue key store.
Proof.
  intros.
  unfold busy.
  rewrite busyFetch_unfold_eq. (* Generated by Equations *)
  unfold busyFetch_unfold.
  rewrite H.
  auto.
Qed.

Lemma busy_does_not_corrupt_inputs'
  {V : Type}
  (tasks : AcyclicTasks Monad V)
  (key : nat)
  (store : Store unit nat V)
  (result : Store unit nat V)
  :
  tasks key = Nothing ->
  result = (busy tasks key store) ->
  getValue key result = getValue key store.
Proof.
  intros.
  rewrite H0.
  unfold busy.
  rewrite busyFetch_unfold_eq. (* Generated by Equations *)
  unfold busyFetch_unfold.
  rewrite H.
  auto.
Qed.

(* The result is consistent with the tasks, i.e. for all non-input keys k ∈ O, the result of *)
(* recomputing the corresponding task matches the value stored in the result: *)
(* getValue k result == compute task result. *)
Lemma busy_correct_part_2
  {V : Type}
  (tasks : AcyclicTasks Monad V)
  (key : nat)
  (task  : Task Monad {x : nat | key > x} V)
  (store : Store unit nat V)
  (result : Store unit nat V):
  tasks key = Just task ->
  result = busy tasks key store ->
  getValue key result = compute task result.
Proof.